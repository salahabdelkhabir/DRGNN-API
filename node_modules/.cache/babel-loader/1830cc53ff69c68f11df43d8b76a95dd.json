{"ast":null,"code":"import { ACTION_TYPES } from 'stores/actions';\n\nconst rootReducer = (state, action) => {\n  switch (action.type) {\n    case ACTION_TYPES.Load_Drug_Options:\n      return { ...state,\n        drugPredictions: action.payload.drugPredictions\n      };\n\n    case ACTION_TYPES.Load_Disease_Options:\n      return { ...state,\n        diseaseOptions: action.payload.diseaseOptions\n      };\n\n    case ACTION_TYPES.Load_Node_Types:\n      return { ...state,\n        nodeTypes: action.payload.nodeTypes\n      };\n\n    case ACTION_TYPES.Load_Edge_Types:\n      return { ...state,\n        edgeTypes: action.payload.edgeTypes\n      };\n\n    case ACTION_TYPES.Change_Disease:\n      return { ...state,\n        selectedDisease: action.payload.selectedDisease,\n        attention: {},\n        metaPathGroups: {},\n        metaPathSummary: [],\n        caseDescription: undefined\n      };\n\n    case ACTION_TYPES.Change_Drug:\n      return { ...state,\n        drugPredictions: toggleDrugSelection(state.drugPredictions, action.payload.selectedDrug)\n      };\n\n    case ACTION_TYPES.Load_Node_Name_Dict:\n      return { ...state,\n        nodeNameDict: action.payload.nodeNameDict\n      };\n\n    case ACTION_TYPES.Set_Loading_Status:\n      return { ...state,\n        ...action.payload\n      };\n\n    case ACTION_TYPES.Select_Path_Noes:\n      return { ...state,\n        selectedPathNodes: action.payload.selectedPathNodes\n      };\n\n    case ACTION_TYPES.Change_Edge_THR:\n      {\n        return { ...state,\n          edgeThreshold: action.payload.edgeThreshold\n        };\n      }\n\n    case ACTION_TYPES.Toggle_Meta_Path_Hide:\n      {\n        return { ...state,\n          metaPathSummary: action.payload.metaPathSummary\n        };\n      }\n\n    case ACTION_TYPES.Add_Attention_Paths:\n      {\n        return { ...state,\n          attention: { ...state.attention,\n            ...action.payload.attention\n          },\n          metaPathGroups: { ...state.metaPathGroups,\n            ...action.payload.metaPathGroups\n          },\n          metaPathSummary: updateMetaPathSummary(state.metaPathSummary, action.payload.metaPathGroups[action.payload.selectedDrug], action.payload.selectedDrug, true // whether add new drug\n          )\n        };\n      }\n\n    case ACTION_TYPES.Update_Case_Description:\n      {\n        return { ...state,\n          caseDescription: action.payload.caseDescription\n        };\n      }\n\n    case ACTION_TYPES.Del_Attention_Paths:\n      {\n        // deep copy\n        let attention = JSON.parse(JSON.stringify(state.attention)),\n            metaPathGroups = JSON.parse(JSON.stringify(state.metaPathGroups));\n        delete attention[`drug:${action.payload.selectedDrug}`];\n        delete metaPathGroups[action.payload.selectedDrug];\n        return { ...state,\n          attention,\n          metaPathGroups,\n          metaPathSummary: updateMetaPathSummary(state.metaPathSummary, metaPathGroups[action.payload.selectedDrug], action.payload.selectedDrug, false // whether add new drug\n          )\n        };\n      }\n\n    default:\n      return state;\n  }\n};\n\nconst toggleDrugSelection = (drugPredictions, selectedDrug) => {\n  return drugPredictions.map(d => {\n    return { ...d,\n      selected: selectedDrug === d.id ? !d.selected : d.selected\n    };\n  });\n};\n\nconst updateMetaPathSummary = (oldSummary, currentMetaPaths, drugId, isAdd) => {\n  let newSummary = oldSummary.map(d => d); // if add new drug\n\n  if (isAdd) {\n    currentMetaPaths.forEach(metaPath => {\n      let count = metaPath.paths.length;\n      let sharedMeta = newSummary.find(d => d.nodeTypes.join() === metaPath.nodeTypes.join());\n\n      if (sharedMeta) {\n        // if shared meta path exists\n        sharedMeta.count[drugId] = count;\n        sharedMeta.sum += count;\n      } else {\n        // if shared meta path does not exist\n        newSummary.unshift({\n          nodeTypes: metaPath.nodeTypes,\n          count: {\n            [drugId]: count\n          },\n          sum: count,\n          hide: false,\n          expand: false,\n          idx: newSummary.length\n        });\n      }\n    });\n  } else {\n    // if delete existing drug\n    newSummary.forEach(metaPath => {\n      if (drugId in metaPath.count) {\n        metaPath.sum -= metaPath.count[drugId];\n        delete metaPath.count[drugId];\n      }\n    });\n  }\n\n  newSummary = newSummary.filter(d => d.sum > 0);\n  return newSummary;\n};\n\nexport const isAddDrug = (drugPredictions, drugID) => {\n  return !drugPredictions.filter(d => d.selected).map(d => d.id).includes(drugID);\n};\nexport default rootReducer;","map":{"version":3,"sources":["D:/Downloads/Explorer_V2/src/stores/reducer.ts"],"names":["ACTION_TYPES","rootReducer","state","action","type","Load_Drug_Options","drugPredictions","payload","Load_Disease_Options","diseaseOptions","Load_Node_Types","nodeTypes","Load_Edge_Types","edgeTypes","Change_Disease","selectedDisease","attention","metaPathGroups","metaPathSummary","caseDescription","undefined","Change_Drug","toggleDrugSelection","selectedDrug","Load_Node_Name_Dict","nodeNameDict","Set_Loading_Status","Select_Path_Noes","selectedPathNodes","Change_Edge_THR","edgeThreshold","Toggle_Meta_Path_Hide","Add_Attention_Paths","updateMetaPathSummary","Update_Case_Description","Del_Attention_Paths","JSON","parse","stringify","map","d","selected","id","oldSummary","currentMetaPaths","drugId","isAdd","newSummary","forEach","metaPath","count","paths","length","sharedMeta","find","join","sum","unshift","hide","expand","idx","filter","isAddDrug","drugID","includes"],"mappings":"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","sourcesContent":["import { IState, IAction, IMetaPathSummary, IMetaPath } from 'types';\nimport { ACTION_TYPES } from 'stores/actions';\n\nconst rootReducer = (state: IState, action: IAction): IState => {\n  switch (action.type) {\n    case ACTION_TYPES.Load_Drug_Options:\n      return {\n        ...state,\n        drugPredictions: action.payload.drugPredictions,\n      };\n\n    case ACTION_TYPES.Load_Disease_Options:\n      return { ...state, diseaseOptions: action.payload.diseaseOptions };\n\n    case ACTION_TYPES.Load_Node_Types:\n      return { ...state, nodeTypes: action.payload.nodeTypes };\n\n    case ACTION_TYPES.Load_Edge_Types:\n      return { ...state, edgeTypes: action.payload.edgeTypes };\n\n    case ACTION_TYPES.Change_Disease:\n      return {\n        ...state,\n        selectedDisease: action.payload.selectedDisease,\n        attention: {},\n        metaPathGroups: {},\n        metaPathSummary: [],\n        caseDescription: undefined,\n      };\n\n    case ACTION_TYPES.Change_Drug:\n      return {\n        ...state,\n        drugPredictions: toggleDrugSelection(\n          state.drugPredictions,\n          action.payload.selectedDrug\n        ),\n      };\n\n    case ACTION_TYPES.Load_Node_Name_Dict:\n      return { ...state, nodeNameDict: action.payload.nodeNameDict };\n\n    case ACTION_TYPES.Set_Loading_Status:\n      return { ...state, ...action.payload };\n\n    case ACTION_TYPES.Select_Path_Noes:\n      return { ...state, selectedPathNodes: action.payload.selectedPathNodes };\n\n    case ACTION_TYPES.Change_Edge_THR: {\n      return { ...state, edgeThreshold: action.payload.edgeThreshold };\n    }\n\n    case ACTION_TYPES.Toggle_Meta_Path_Hide: {\n      return { ...state, metaPathSummary: action.payload.metaPathSummary };\n    }\n\n    case ACTION_TYPES.Add_Attention_Paths: {\n      return {\n        ...state,\n        attention: { ...state.attention, ...action.payload.attention },\n        metaPathGroups: {\n          ...state.metaPathGroups,\n          ...action.payload.metaPathGroups,\n        },\n        metaPathSummary: updateMetaPathSummary(\n          state.metaPathSummary,\n          action.payload.metaPathGroups[action.payload.selectedDrug],\n          action.payload.selectedDrug,\n          true // whether add new drug\n        ),\n      };\n    }\n\n    case ACTION_TYPES.Update_Case_Description: {\n      return { ...state, caseDescription: action.payload.caseDescription };\n    }\n\n    case ACTION_TYPES.Del_Attention_Paths: {\n      // deep copy\n      let attention = JSON.parse(JSON.stringify(state.attention)),\n        metaPathGroups = JSON.parse(JSON.stringify(state.metaPathGroups));\n\n      delete attention[`drug:${action.payload.selectedDrug}`];\n      delete metaPathGroups[action.payload.selectedDrug];\n      return {\n        ...state,\n        attention,\n        metaPathGroups,\n        metaPathSummary: updateMetaPathSummary(\n          state.metaPathSummary,\n          metaPathGroups[action.payload.selectedDrug],\n          action.payload.selectedDrug,\n          false // whether add new drug\n        ),\n      };\n    }\n\n    default:\n      return state;\n  }\n};\n\nconst toggleDrugSelection = (\n  drugPredictions: IState['drugPredictions'],\n  selectedDrug: string\n) => {\n  return drugPredictions.map((d) => {\n    return {\n      ...d,\n      selected: selectedDrug === d.id ? !d.selected : d.selected,\n    };\n  });\n};\n\nconst updateMetaPathSummary = (\n  oldSummary: IMetaPathSummary[],\n  currentMetaPaths: IMetaPath[],\n  drugId: number,\n  isAdd: boolean\n) => {\n  let newSummary = oldSummary.map((d) => d);\n\n  // if add new drug\n  if (isAdd) {\n    currentMetaPaths.forEach((metaPath) => {\n      let count = metaPath.paths.length;\n      let sharedMeta = newSummary.find(\n        (d) => d.nodeTypes.join() === metaPath.nodeTypes.join()\n      );\n      if (sharedMeta) {\n        // if shared meta path exists\n        sharedMeta.count[drugId] = count;\n        sharedMeta.sum += count;\n      } else {\n        // if shared meta path does not exist\n        newSummary.unshift({\n          nodeTypes: metaPath.nodeTypes,\n          count: { [drugId]: count },\n          sum: count,\n          hide: false,\n          expand: false,\n          idx: newSummary.length,\n        });\n      }\n    });\n  } else {\n    // if delete existing drug\n\n    newSummary.forEach((metaPath) => {\n      if (drugId in metaPath.count) {\n        metaPath.sum -= metaPath.count[drugId];\n        delete metaPath.count[drugId];\n      }\n    });\n  }\n  newSummary = newSummary.filter((d) => d.sum > 0);\n  return newSummary;\n};\n\nexport const isAddDrug = (\n  drugPredictions: IState['drugPredictions'],\n  drugID: string\n) => {\n  return !drugPredictions\n    .filter((d) => d.selected)\n    .map((d) => d.id)\n    .includes(drugID);\n};\nexport default rootReducer;\n"]},"metadata":{},"sourceType":"module"}